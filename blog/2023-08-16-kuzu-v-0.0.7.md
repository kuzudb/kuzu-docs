---
slug: kuzu-0.0.7-release
authors: [team]
tags: [release]
---

<!-- omit from toc -->
# Kùzu 0.0.7 Release
We are very happy to release Kùzu 0.0.7 today! This release comes with the following new main features and improvements: 

- [Node Group Based Node Table Storage](#node-group-based-node-table-storage)
- [Cypher Features](#cypher-features)
  - [Merge Clause](#merge-clause)
  - [Create Macro](#create-macro)
  - [Multi-label Create/Set/Delete](#multi-label-createsetdelete)
  - [Return After Update](#return-after-update)
- [Unnest Arbitrary Subqueries](#unnest-arbitrary-subqueries)
- [Data Export](#data-export)
- [Data Types](#data-types)
  - [MAP](#map)
  - [UNION](#union)
- [Client APIs](#client-apis)
  - [C++ UDF](#c-udf)
  - [Converting Query Result to Arrow available in Rust, C, and C++](#converting-query-result-to-arrow-available-in-rust-c-and-c)

<!--truncate-->

For installing the new version, 
please visit the [download section of our website](https://kuzudb.com/#download) 
and [getting started guide](https://kuzudb.com/docusaurus/getting-started/) and the full
[release notes are here](https://github.com/kuzudb/kuzu/releases). 

## Node Group Based Node Table Storage
This release changes the storage layout of node tables to be node group-based.
Before this release, we store each column contiguously in separate files.
Each column contains one data file (e.g., `n-1.col`) and one null file (e.g., `n-1.null`) if the column may contain null values.
This design poses two problems: 1) it comes with many files in the database directory, which can lead to `too many open files` error on systems with a small value for max number of open files; 2) it is not optimized for data compression, which is one great advantage of columnar storage. Partitioning each column into multiple chunks can offer more flexibility as each column chunk can be compressed and decompressed independently compared to compressing the whole column at one time.

In the new design, we introduce the concept of *NodeGroup*, which is equivalent to *RowGroup*, commonly phrased in columnar file formats (e.g., Orc and Parquet), in the sense that they both represent a horizontal partition of a table. We use the term NodeGroup mainly due to that we also partition rel tables based on their src/dst nodes, instead of number of rows.
Within a node group, each property of the table has a chunk of its data stored sequentially in the file. Each column chunk is independent, and can be compressed using different algorithms.

In this release, we've integrated node group-based storage design with node tables together with compressing null and bools into bits.
Now all column data of node tables are now stored in a single file `data.kz`.[^1]
The integration with rel tables and more powerful compression schemes, e.g., constant compression, bitpacking, dictionary compression, will come soon.
For details on our new design, please visit [this issue](https://github.com/kuzudb/kuzu/issues/1474).

[^1]: Primary key index files are still kept separately, but eventually they will also be merged into the `data.kz` file.

## Cypher Features

### Merge Clause
This release introduces `MERGE` clause which is an updating clause that will first try to match the given pattern and, if not found, create the pattern. At a high level, `MERGE <pattern>` can be interpreted as `If MATCH <pattern> then RETURN <pattern> ELES CREATE <patten>`. Additionally, user can specify further `SET` operation based on whether the pattern is found or not through `ON CREATE` and `ON MATCH`.

For example, the following query tries to merge a user node with name "Adam". Since the tuple exists in the database, we update its age property and return the tuple.
```
MERGE (n:User {name : 'Adam'}) ON MATCH SET n.age = 35 RETURN n.*;
------------------
| n.name | n.age |
------------------
| Adam   | 35    |
------------------
```
Below is another example where we try to merge a follows edge since 2022 between "Adam" and "Karissa". Since no such edge exists, we create the edge and set the since property to 1999.
```
MATCH (a:User), (b:User) 
WHERE a.name = 'Adam' AND b.name = 'Karissa' 
MERGE (a)-[e:Follows {since:2022}]->(b) 
ON CREATE SET e.since = 1999
RETURN e;
---------------------------------------------------------
| e                                                     |
---------------------------------------------------------
| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 1999}->(0:1) |
---------------------------------------------------------
```

### Create Macro 
In this release, we've added the support of `CREATE MACRO` statement to define customized scalar function through Cypher.
Note that a scalar macro is limited to returning only a single value.

Here is an example of defining a macro to add two input parameters, while the second one is provided with a default value.
```Cypher
// Create a macro which adds two parameters. If the second parameter(b) is not provided, the default value (3) will be used instead.
create macro addWithDefault(a,b:=3) as a + b;
// Executes the macro without providing the default value.
return addWithDefault(2);  // returns 5 (2 + 3)
// Executes the macro by providing the default value (actual parameter value will be used).
return addWithDefault(4, 7);  // returns 11 (4 + 7)
```

See more details on supported macro expression types [here](./../cypher/macro).

### Multi-label Set/Delete

Kùzu now allows set/delete on multi-labeled nodes and relationships.

To delete all nodes in database (assuming all edges have been deleted).
```
MATCH (n) DELETE n;
```
To set `since` property of all relationships.
```
MATCH ()-[f]->() SET f.since = 2023
```

### Return After Update

We also enable return after updating clause starting from this release. Updated value will be returned.

```
MATCH (u:User) WHERE u.name = 'Adam' SET u.age = NULL RETURN u.*;
------------------
| u.name | u.age |
------------------
| Adam   |       |
------------------

MATCH (u1:User), (u2:User) WHERE u1.name = 'Adam' AND u2.name = 'Noura' 
CREATE (u1)-[e:Follows {since: 2011}]->(u2) RETURN e;
---------------------------------------------------------
| e                                                     |
---------------------------------------------------------
| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 2011}->(0:3) |
---------------------------------------------------------
```

### Return with .*
As a syntactic sugar, Kùzu supports returning all properties of node or rel with *.
```
MATCH (a:User) RETURN a.*;
-------------------
| a.name  | a.age |
-------------------
| Adam    | 30    |
-------------------
| Karissa | 40    |
-------------------
| Zhang   | 50    |
-------------------
| Noura   | 25    |
-------------------
```

## Unnest Arbitrary Subqueries

Consider the following query that finds the name of user follows at least one user that is younger.
```
MATCH (a:User) 
WHERE EXISTS { MATCH (a)-[:Follows]->(b:User) WHERE a.age > b.age } 
RETURN a.name;
```
The query inside `EXISTS` is a correlated subquery and very expensive to evaluate because the inner subquery need to be evaluated for each tuple of "a" with nested loop join. 

In this release, we implemented unnest correlated subquery based on the paper [Unnesting Arbitrary Queries](Unnesting Arbitrary Queries) and move to hash join based solution. The following plan will be generated for the above query.

```
        Hash Join
  /          |        \
Scan(t1)  Build(t2)  Build(t1)
             |          |
          Extend(b)   Scan(a)
             |
         Distinct()
             |
          Scan(t1)
```

The plan executed from right to left. We first scan table `a` from disk and materialize a hash table `t1`, `t1` is then scanned in the middle pipeline for subquery evaluation whose result is materialized as hash table `t2`. Finally, we scan `t1` again in the left pipeline and probe `t2` to perform the hash join. In such case, we avoid repeated evaluation of subquery for each input. More details will come in a separate blog post.

## Data Export
Kùzu now supports export query results to CSV files using the `COPY TO` command. This feature enables seamless extraction of query outputs into CSV format. By default, headers are included, and data fields are comma-separated. For instance:

```
COPY (MATCH (p:person) RETURN p.ID, p.name) TO 'person.csv';
```

The resulting CSV file maintains the query's structure:

```
p.ID,p.name
0,"Alice"
2,"Bob"
3,"Carol"
5,"Dan"
9,"Greg"
...
```

Even nested data types like lists and structs are appropriately captured in the exported CSV. This enhancement simplifies data export and facilitates compatibility with external tools and systems. See [Data Export](../data-export/) on our documentation for more information.
## Data Types

### MAP

### UNION

## Client APIs

### C++ UDF
Besides Macro, this release also introduces two C++ interfaces (`createScalarFunction` and `createVectorizedFunction` in `Connection`) to define both scalar and vectorized [UDFs](./../client-apis/cpp-api/udf).

`createScalarFunction` provides a way for users to define scalar functions in C++ and use it in Kùzu as if they're built-in functions.
One example of a unary scalar function that increments the input value by 5 is as follows:
```cpp
// Create a unary scalar function which adds 5 to the input value.
static int32_t addFiveScalar(int32_t x) {
    return x + 5;
}
// Register the unary scalar function using the createScalarFunction API.
conn->createScalarFunction("addFiveScalar", &addFiveScalar);
// Issue a query using the UDF.
conn->query("MATCH (p:person) return addFiveScalar(to_int32(p.age))");
```

For users familiar with internals of our intermediate result representation, they can make use of vectorization to obtain better performance on unFlat ValueVector.
```cpp
// Create a vectorized function which adds 5 to each value.
static void addFiveVectorized(
    const std::vector<std::shared_ptr<ValueVector>>& parameters, ValueVector& result) {
    assert(parameters.size() == 1);
    auto parameter = parameters[0];
    result.resetAuxiliaryBuffer();
    result.state = parameter->state;
    if (parameter->state->isFlat()) {
        auto pos = parameter->state->selVector->selectedPositions[0];
        result.setValue(pos, parameter->getValue<int64_t>(pos) + 5);
    } else {
        for (auto i = 0u; i < parameter->state->selVector->selectedSize; i++) {
            auto pos = parameter->state->selVector->selectedPositions[i];
            result.setValue(pos, parameter->getValue<int64_t>(pos) + 5);
        }
    }
}
// Register the vectorized function using the createVectorizedFunction API.
conn->createVectorizedFunction<int64_t, int64_t>("addFiveVectorized", &addFiveVectorized);
// Issue a query using the UDF.
conn->query("MATCH (p:person) return addFour(p.age)");
```

### Converting Query Result to Arrow available in Rust, C, and C++

