---
slug: kuzu-0.0.7-release
authors: [team]
tags: [release]
---

# Kùzu 0.0.7 Release
We are very happy to release Kùzu 0.0.7 today! This release comes with the following new main features and improvements: 

- [Macro and UDF](#macro-and-udf)
  - [Create Macro Statements](#create-macro-statements)
  - [C++ UDFs](#c-udfs)
- [Node Group Based Node Table Storage](#node-group-based-node-table-storage)
- [Data Update and Return Clauses](#data-update-and-return-clauses)
  - [Merge Clause](#merge-clause)
  - [Multi-label Set/Delete](#multi-label-setdelete)
  - [Return After Update](#return-after-update)
  - [Return with .\*](#return-with-)
- [Data Export](#data-export)
- [Data Types and APIs](#data-types-and-apis)
  - [MAP](#map)
  - [UNION](#union)
  - [Converting Query Results to Arrow](#converting-query-results-to-arrow)
- [Unnesting Arbitrary Subqueries](#unnesting-arbitrary-subqueries)

<!--truncate-->

For installing the new version, 
please visit the [download section of our website](https://kuzudb.com/#download) 
and [getting started guide](https://kuzudb.com/docusaurus/getting-started/). The full
[release notes are here](https://github.com/kuzudb/kuzu/releases). 

## Macro and UDF
### Create Macro Statements
In this release, we've added the support of `CREATE MACRO` statement to define customized scalar functions, i.e., those that return only a single value, through Cypher.

Here is an example of defining a macro to add two input parameters.  The second parameter `b:3` is an example of how to provide a default value for a parameter in case the parameter is absent.
```Cypher
// Create a macro which adds two parameters. If the second parameter b is not provided, the default value of 3 will be used instead.
create macro addWithDefault(a,b:=3) as a + b;
// Executes the macro without providing the default value.
return addWithDefault(2);  // returns 5 (2 + 3)
// Executes the macro by providing the default value (actual parameter value will be used).
return addWithDefault(4, 7);  // returns 11 (4 + 7)
```
See more details on supported macro expression types [here](./../cypher/macro).

### C++ UDFs
We are also introducing two C++ interfaces, `createScalarFunction` and `createVectorizedFunction` in the `Connection` class of the [C++ API](https://kuzudb.com/docusaurus/getting-started/cpp) to define both scalar and vectorized [UDFs](./../client-apis/cpp-api/udf).

`createScalarFunction` provides a way for users to define scalar functions in C++ and use it in Kùzu as if they're built-in functions.
Here is an example of a unary scalar function that increments the input value by 5:
```cpp
static int32_t addFiveScalar(int32_t x) {
    return x + 5;
}
// Register the unary scalar function using the createScalarFunction API.
conn->createScalarFunction("addFiveScalar", &addFiveScalar);
// Issue a query using the UDF.
conn->query("MATCH (p:person) return addFiveScalar(to_int32(p.age))");
```

For users familiar with internals of our intermediate result representation, they can make use of `createVectorizedFunction` to create vectorized function over our ValueVectors to achieve better performance.
See [our doc here](./../client-apis/cpp-api/udf) for more details.

## Node Group Based Node Table Storage
This release introduces changes the storage layout of node tables.
Before this release, we store each column in a node table contiguously in separate files.
Each column contains one data file (e.g., `n-1.col`) and one null file (e.g., `n-1.null`) if the column may contain null values.
This design poses two problems: 1) it comes with many files in the database directory, which may easily lead to `too many open files` error; 2) it is not optimized for data compression, which is one great advantage of columnar storage. 

Partitioning each column into multiple chunks can offer more flexibility as each column chunk can be compressed and decompressed independently.
In this release, we introduced the concept [NodeGroup](https://github.com/kuzudb/kuzu/issues/1474), which is equivalent to [RowGroup](https://parquet.apache.org/docs/concepts/) in the sense that they both represent a horizontal partition of a table.[^1] 
With node group-based storage design, we store data of all columns in a single file `data.kz`.[^2]
This will enable more powerful compression schemes, e.g., constant compression, bit-packing, dictionary compression in the coming releases.
For details on our new design, please visit [this issue](https://github.com/kuzudb/kuzu/issues/1474).

[^1]: We use the term NodeGroup mainly due to that we also partition rel tables based on their src/dst nodes, instead of number of rows.
[^2]: Primary key index files are still kept separately, but eventually they will also be merged into the `data.kz` file.

## Data Update and Return Clauses
### Merge Clause
This release introduces `MERGE` clause which is an updating clause that will first try to match the given pattern and, if not found, create the pattern. At a high level, `MERGE <pattern>` can be interpreted as `If MATCH <pattern> then RETURN <pattern> ELES CREATE <patten>`. Additionally, user can specify further `SET` operation based on whether the pattern is found or not through `ON CREATE` and `ON MATCH`.

For example, the following query tries to merge a user node with name "Adam". Since the tuple exists in the database, we update its age property and return the tuple.
```
MERGE (n:User {name : 'Adam'}) ON MATCH SET n.age = 35 RETURN n.*;
------------------
| n.name | n.age |
------------------
| Adam   | 35    |
------------------
```
Below is another example where we try to merge a follows edge since 2022 between "Adam" and "Karissa". Since no such edge exists, we create the edge and set the since property to 1999.
```
MATCH (a:User), (b:User) 
WHERE a.name = 'Adam' AND b.name = 'Karissa' 
MERGE (a)-[e:Follows {since:2022}]->(b) 
ON CREATE SET e.since = 1999
RETURN e;
---------------------------------------------------------
| e                                                     |
---------------------------------------------------------
| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 1999}->(0:1) |
---------------------------------------------------------
```

### Multi-label Set/Delete

Kùzu now allows set/delete on multi-labeled nodes and relationships.

To delete all nodes in database (assuming all edges have been deleted).
```
MATCH (n) DELETE n;
```
To set `since` property of all relationships.
```
MATCH ()-[f]->() SET f.since = 2023
```

### Return After Update

We also enable return after updating clause starting from this release. Updated value will be returned.

```
MATCH (u:User) WHERE u.name = 'Adam' SET u.age = NULL RETURN u.*;
------------------
| u.name | u.age |
------------------
| Adam   |       |
------------------

MATCH (u1:User), (u2:User) WHERE u1.name = 'Adam' AND u2.name = 'Noura' 
CREATE (u1)-[e:Follows {since: 2011}]->(u2) RETURN e;
---------------------------------------------------------
| e                                                     |
---------------------------------------------------------
| (0:0)-{_LABEL: Follows, _ID: 0:5, since: 2011}->(0:3) |
---------------------------------------------------------
```

### Return with .*
As a syntactic sugar, Kùzu supports returning all properties of node or rel with *.
```
MATCH (a:User) RETURN a.*;
-------------------
| a.name  | a.age |
-------------------
| Adam    | 30    |
-------------------
| Karissa | 40    |
-------------------
| Zhang   | 50    |
-------------------
| Noura   | 25    |
-------------------
```

## Data Export
Kùzu now supports export query results to CSV files using the `COPY TO` command. 
```
COPY (MATCH (u:User) RETURN u.*) TO 'user.csv';
```
The CSV file will be written as follow:
```
u.name,u.age
"Adam",30
"Karissa",40
"Zhang",50
"Noura",25
```
See [Data Export](../data-export/) for more information.

## Data Types and APIs
### MAP
A `MAP` is a dictionary of key-value pairs where all keys have the same type and all values have the same type. Different from `STRUCT`, `MAP` doesn't require the same key to present in each row. Therefore, `MAP` is more suitable when the schema is not determined.

```
RETURN map([1, 2], ['a', 'b']) AS m;
--------------
| m          |
--------------
| {1=a, 2=b} |
--------------
```

See [map](../docs/cypher/data-types/map.md) for more information.

### UNION
Kùzu's `UNION` is implemented by taking DuckDB's `UNION` type as a reference. Similar to C++ `std::variant`, `UNION` is a nested data type that is capable of holding multiple alternative values with different types. The value under key "tag" is considered as the value being currently hold by the `UNION`.

See [union](../docs/cypher/data-types/union.md) for more information.

### Converting Query Results to Arrow
In previous releases, we've supported converting query result to arrow table in our [Python API](./../client-apis/python-api/query-result) (See `get_as_arrow`).
In this release, converting to arrow arrays are now also available in Rust, [C](./../client-apis/c-api/query_result) (see `kuzu_query_result_get_arrow_schema` and `kuzu_query_result_get_next_arrow_chunk`), and [C++](./../client-apis/cpp-api/query-result) (see `getArrowSchema` and `getNextArrowChunk`) APIs.


## Unnesting Arbitrary Subqueries

Consider the following query that finds the name of users `a` who have at least 1 user `b` who is younger than `a`:
```
MATCH (a:User) 
WHERE EXISTS { MATCH (a)-[:Follows]->(b:User) WHERE a.age > b.age} 
RETURN a.name;
```
The query inside `EXISTS` is a correlated subquery and very expensive to evaluate because the inner subquery needs to be evaluated for each `a` with a nested loop join operator (which is often an inefficient way to evaluate joins). In this release, we implemented an optimization that unnests correlated subqueries based on the techniques adopted from this BTW paper [Unnesting Arbitrary Queries](https://cs.emis.de/LNI/Proceedings/Proceedings241/383.pdf) by Neumann and Kemper. This allows us to use hash joins instead of nested loop joins and execute these queries much faster. More details will come in a separate blog post on both this technique and how much gains we obtain.
