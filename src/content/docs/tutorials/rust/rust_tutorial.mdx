---
title: "Rust tutorial: Social Network"
---

import { CardGrid, LinkCard } from '@astrojs/starlight/components';

This tutorial will get you started using Kùzu's Rust API to analyze a community of users on a social network.

The example database's schema can be found below:

<LinkCard
title="Example Database"
description="Database schema used in API tutorials"
href="/tutorials/example-database"
/>

## Setup

First ensure that you have Rust installed on your system. Then, install the Rust API of Kùzu
via the following steps:

```bash
# Initialize a new Rust project
cargo new social_network_rs
cd social_network_rs
# Install the Rust API of Kùzu into the project
cargo add kuzu
```

Create a new directory at the root level of the project called `data`. Next, [download the zipped data](https://rgw.cs.uwaterloo.ca/kuzu-test/tutorial/tutorial_data.zip), unzip the files and copy them to the `data` directory.
Your directory should look like:
```
data/
├── node/
│   ├── user.csv
│   ├── post.csv
├── relation/
│   ├── FOLLOWS.csv
│   ├── POSTS.csv
│   ├── LIKES.csv
```

Replace `main.rs` with the following code snippet:
```rs
use kuzu::{Connection, Database, Error, SystemConfig};

fn main() -> Result<(), Error> {
    // This is where our queries will be inputted and executed.

}
```

We are now ready to start the tutorial.

## Create an instance of the database
In order to create the graph in Kùzu, we first need to create a new Kùzu database. We do this by using the following commands in Rust:
```rs
// Create an empty on-disk database and connect to it
let db = Database::new("./social_network_rs_db", SystemConfig::default())?;
let conn = Connection::new(&db)?;
```
This will create a database directory called `./social_network_rs_db`, where our data will be stored. Kùzu also supports `in-memory mode` in which case the lifetime of the database will be only during the execution of the Rust program.
For more information, please refer to our docs on [Create your first graph](/get-started/#index).

## Define schema
The first step in building any Kùzu graph is schema definition. We will define the node and relationships tables as per our desired schema as follows:
```rs
conn.query("
    CREATE NODE TABLE User(
    user_id INT64 PRIMARY KEY, 
    username STRING, 
    account_creation_date DATE)
    ")?;
conn.query("
    CREATE NODE TABLE Post(
    post_id INT64 PRIMARY KEY, 
    post_date DATE, 
    like_count INT64, 
    retweet_count INT64)
    ")?;
conn.query("
    CREATE REL TABLE FOLLOWS(
    FROM User TO User)
    ")?;
conn.query("
    CREATE REL TABLE POSTS(
    FROM User TO Post)
    ")?;
conn.query("
    CREATE REL TABLE LIKES(FROM User TO Post)
    ")?;
```
:::caution[note]
When creating table, it is required to provide the column name and column type, with `,` separating each column. 
It is also required that exactly one column is explicitly stated to be the PRIMARY KEY column. This is the column which is used to sort entries in the table. 
User may define this PRIMARY KEY by appending the keyword `PRIMARY KEY` after any of the column definitions, or by appending `PRIMARY KEY(column_name)` as the last parameter of the creation clause. 

For more information on the syntax of table creation, please refer to our documentation on [Syntax](/cypher/syntax)
:::

## Checking table information
We can check information on the tables we have in the database with the following commands:
```rs
let result = conn.query("CALL SHOW_TABLES() RETURN *")?;
```
Returns:
```
id|name|type|database name|comment
2|FOLLOWS|REL|local(kuzu)|
1|Post|NODE|local(kuzu)|
0|User|NODE|local(kuzu)|
4|LIKES|REL|local(kuzu)|
3|POSTS|REL|local(kuzu)|
```

Alternatively, we can also export the data into csv files for external processing.
```rs
conn.query("
    COPY (CALL SHOW_TABLES() RETURN *) 
    TO 'tables.csv' (header=true)
    ")?;
```
For more information on data exporting, please referring to our documentation on [export data](/export/#index).

## Import data
After creating the tables, we can import the data. We do so by using the `COPY FROM` commands, like this:
```rs
conn.query("COPY User FROM './data/node/user.csv'")?;
conn.query("COPY Post FROM './data/node/post.csv'")?;
conn.query("COPY FOLLOWS FROM './data/relation/FOLLOWS.csv'")?;
conn.query("COPY POSTS FROM './data/relation/POSTS.csv'")?;
conn.query("COPY LIKES FROM './data/relation/LIKES.csv'")?;
```
For more information on loading in data, please refer to our documentation on  [import data](/import/csv).

## Querying queries
We can now proceed to querying the database to answer some questions about the social network. Here are some examples of what queries can be answered with ease using Kùzu:

### Q1: Which user has the most followers? And how many followers do they have?
We can break the query down into a few steps:
1. We can first use the `MATCH` query to find the relationship specified, in this case, we want to look at `User` node at the end of the relation `FOLLOWS`:
```rs
let result = conn.query("
    MATCH (u1:User)-[f:FOLLOWS]->(u2:User) 
    RETURN u2.username
    LIMIT 5
    ")?;
result.display();
```

Returns:
```
u2.username
epicwolf202
epicwolf202
epicwolf202
silentninja637
silentninja637
```

For more information on `MATCH`, please refer to our documentation in [Cypher Manual](/cypher/#index).

For each relation `FOLLOWS`, this will return the followee's username of that relation. While this doesn't provide much useful information yet, we may improve on this query by using aggregation.

2. We can then use aggregation function to count the number of appearnces of a followee, by adding `count(u2) as follower_count` to the `RETURN` statement:
```rs
let result = conn.query("
    MATCH (u1:User)-[f:FOLLOWS]->(u2:User) 
    RETURN u2.username, count(u2) as follower_count 
    LIMIT 5
    ")?;
println!("{}", result.display());
```
Returns
```
u2.username|follower_count
fastgirl798|4
epicking81|3
stormcat597|2
epiccat105|4
darkdog878|6
```
This is a lot more useful! we can now clearly see how many follower each user has.
3. Lastly, we use `ORDER BY` and `LIMIT` to order the usernames by their amount of followers, and return only the first entry. This is the user we are looking for, and how many followers that user has:
```rs
let result = conn.query("
    MATCH (u1:User)-[f:FOLLOWS]->(u2:User) 
    RETURN u2.username, count(u2) as follower_count 
    ORDER BY follower_count DESC 
    LIMIT 1
    ")?;
println!("{}", result.display());
```
Returns:
```
u2.username|follower_count
darkdog878|6
```

### Q2: What is the shortest path between two users?
Another question which we might be interested in answering is finding the shortest path between two users. 
For example, how many follows does it take to get from user `silentguy245` to `epicwolf202`? 
1. We can query this by using [recursive match](/cypher/query-clauses/match) to find shortest path length:
```rs
result = conn.query("
    MATCH p = (u1:user)-[f:FOLLOWS* SHORTEST 1..4]->(u2:User)
    WHERE u1.username = 'silentguy245' 
    AND u2.username = 'epicwolf202'
    RETURN p
    ")?;
println!("{}", result.display());
```
Returns:
```
p
{_NODES: [{_ID: 0:19, _LABEL: User, user_id: 20, username: silentguy245, account_creation_date: 2022-10-11},{_ID: 0:14, _LABEL: User, user_id: 15, username: mysticwolf198, account_creation_date: 2021-01-04},{_ID: 0:0, _LABEL: User, user_id: 1, username: epicwolf202, account_creation_date: 2022-09-09}], _RELS: [(0:19)-{_LABEL: FOLLOWS, _ID: 2:64}->(0:14),(0:14)-{_LABEL: FOLLOWS, _ID: 2:47}->(0:0)]}
```
This will return us a result in `RECURSIVE_REL` datatype, which is diffcult to interpret.
2. We will then simplify the result using some [recursive relationship functions](/cypher/expressions/recursive-rel-functions)
```rs
result = conn.query("
    MATCH p = (u1:user)-[f:FOLLOWS* SHORTEST 1..4]->(u2:User)
    WHERE u1.username = 'silentguy245' 
    AND u2.username = 'epicwolf202'
    RETURN properties(nodes(p), 'username')
    ")?;
println!("{}", result.display());
```
Returns:
```
PROPERTIES(NODES(p),username)
[silentguy245,mysticwolf198,epicwolf202]
```

### Q3: How many 3-hop paths exist between userA and userB that passes through userC?
To answer this query, we should do something similar to Q1. We first match all 3-hop queries:
```rs
result = conn.query("
    MATCH (u1:User)-[f1:FOLLOWS]->(u2:User)-[f2:Follows]->(u3:User)-[f3:FOLLOWS]->(u4:User)
    RETURN count(u4)
    ")?;
println!("{}", result.display());
```
Returns:
```
COUNT(u4._ID)
667
```
Meaning that there are 667 3-hop paths altogether.

Next, we add to the query to match only cases concerning with userA, userB, and userC. In this case, we want to introduce the idea of perpared statements, so that we can easily swap out elements of the query for other users. We arbitrarily choose userA to be `epicwolf202`, userB to be `stormcat597`, and userC to be `stormfox762`
```rs
let u1 = "epicwolf202";
let u2 = "stormcat597";
let u3 = "stormfox762";
let query = format!("
    MATCH (u1:User)-[f1:FOLLOWS]->(u2:User)-[f2:Follows]->(u3:User)-[f3:FOLLOWS]->(u4:User)
    WHERE u1.username= {} AND u4.username= {} AND (u2.username= {} OR u3.username= {})
    RETURN count(u4)
    ", u1, u2, u3, u3);
result = conn.query(&query)?;
println!("{}", result.display());
```
Returns
```
COUNT(u4._ID)
1
```
Meaning there is exactly one 3-hop path between the three users specified.

## Summary
In summary, we've shown how to use Kùzu's Rust API to view our data as a graph, query it in Cypher, and output the results in various formats. Try these methods out on your own datasets, and have fun using Kùzu!

Entire `main.rs`:
```rs
use kuzu::{QueryResult, Connection, Database, Error, SystemConfig};

fn create_table(conn: &Connection) -> Result<(), Error> {
    conn.query("
        CREATE NODE TABLE User(
        user_id INT64 PRIMARY KEY, 
        username STRING, 
        account_creation_date DATE
        )")?;
    conn.query("
        CREATE NODE TABLE Post(
        post_id INT64 PRIMARY KEY, 
        post_date DATE, 
        like_count INT64, 
        retweet_count INT64
        )")?;
    conn.query("CREATE REL TABLE FOLLOWS(
        FROM User TO User
        )")?;
    conn.query("
        CREATE REL TABLE POSTS(
        FROM User TO Post
        )")?;
    conn.query("
        CREATE REL TABLE LIKES(FROM User TO Post
        )")?;
    Ok(())
}

fn populate_data(conn: &Connection) -> Result<(), Error> {
    conn.query("COPY User FROM './data/node/user.csv'")?;
    conn.query("COPY Post FROM './data/node/post.csv'")?;
    conn.query("COPY FOLLOWS FROM './data/relation/FOLLOWS.csv'")?;
    conn.query("COPY POSTS FROM './data/relation/POSTS.csv'")?;
    conn.query("COPY LIKES FROM './data/relation/LIKES.csv'")?;
    Ok(())
}

fn query_one(conn: &Connection) -> Result<(), Error> {
    // Q1
    let mut result = conn.query("
        MATCH (u1:User)-[f:FOLLOWS]->(u2:User) 
        RETURN u2.username
        LIMIT 5
    ")?;
    println!("{}", result.display()); 

    result = conn.query("
        MATCH (u1:User)-[f:FOLLOWS]->(u2:User) 
        RETURN u2.username, count(u2) as follower_count 
        LIMIT 5
    ")?;
    println!("{}", result.display());

    result = conn.query("
        MATCH (u1:User)-[f:FOLLOWS]->(u2:User) 
        RETURN u2.username, count(u2) as follower_count 
        ORDER BY follower_count DESC 
        LIMIT 1
    ")?;
    println!("{}", result.display());
    Ok(())
}

fn query_two(conn: &Connection) -> Result<(), Error> {
    // Q2
    let mut result = conn.query("
        MATCH p = (u1:user)-[f:FOLLOWS* SHORTEST 1..4]->(u2:User)
        WHERE u1.username = 'silentguy245' 
        AND u2.username = 'epicwolf202'
        RETURN p
    ")?;
    println!("{}", result.display());

    result = conn.query("
        MATCH p = (u1:user)-[f:FOLLOWS* SHORTEST 1..4]->(u2:User)
        WHERE u1.username = 'silentguy245' 
        AND u2.username = 'epicwolf202'
        RETURN properties(nodes(p), 'username')
    ")?;
    println!("{}", result.display());
    Ok(())
}

fn query_three(conn: &Connection) -> Result<(), Error> {
    //Q3
    let mut result = conn.query("
        MATCH (u1:User)-[f1:FOLLOWS]->(u2:User)-[f2:Follows]->(u3:User)-[f3:FOLLOWS]->(u4:User)
        RETURN count(u4)
    ")?;
    println!("{}", result.display());

    let u1 = "'epicwolf202'";
    let u2 = "'stormcat597'";
    let u3 = "'stormfox762'";
    let query = format!("
        MATCH (u1:User)-[f1:FOLLOWS]->(u2:User)-[f2:Follows]->(u3:User)-[f3:FOLLOWS]->(u4:User)
        WHERE u1.username = {} AND u4.username = {} AND (u2.username = {} OR u3.username = {})
        RETURN count(u4)
        ", u1, u2, u3, u3);
    result = conn.query(&query)?;
    println!("{}", result.display());
    Ok(())
}

fn main() -> Result<(), Error> {
    // This is where our queries will be inputted and executed.
    // Create an empty on-disk database and connect to it
    let db = Database::new("./social_network_rs_db", SystemConfig::default())?;
    let conn = Connection::new(&db)?;
    create_table(&conn);
    populate_data(&conn);
    let mut result = conn.query("CALL SHOW_TABLES() RETURN *")?;
    println!("{}", result.display());
    query_one(&conn);
    query_two(&conn);
    query_three(&conn);
    Ok(())
}
```