---
title: Data types
---

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

Kùzu supports a set of primitive and nested data types both for node and relationship properties as
well as for forming expressions whose outputs are specified using these data types. This section
shows all built-in data types.

## INT8

| Size | Description
| --- | ---
| 1 byte | signed one-byte integer

## INT16

| Size | Description
| --- | ---
| 2 bytes | signed two-byte integer

## INT32

| Size | Description | Aliases
| --- | --- | ---
| 4 bytes | signed four-byte integer | INT

## INT64

| Size | Description | Aliases
| --- | --- | ---
| 8 bytes | signed eight-byte integer | SERIAL

## INT128

| Size | Description
| --- | ---
| 16 bytes | signed sixteen-byte integer

## UINT8

| Size | Description
| --- | ---
| 1 byte | unsigned one-byte integer

## UINT16

| Size | Description
| --- | ---
| 2 bytes | unsigned two-byte integer

## UINT32

| Size | Description
| --- | ---
| 4 bytes | unsigned four-byte integer

## UINT64

| Size | Description
| --- | ---
| 8 bytes | unsigned eight-byte integer

## FLOAT

| Size | Description | Aliases
| --- | --- | ---
| 4 bytes | single precision floating-point number | REAL, FLOAT4

## DOUBLE

| Size | Description | Aliases
| --- | --- | ---
| 8 bytes | double precision floating-point number | FLOAT8

## DECIMAL

| Size | Description
| --- | ---
| variable | arbitrary fixed precision decimal number

For numbers where exact precision is required, the `DECIMAL` data type can be used. The `DECIMAL` type is
specified as `DECIMAL(precision, scale)`, where `precision` is the total number of digits and
`scale` is the number of digits to the right of the decimal point.

Internally, decimals are represented as integers depending on their specified width.

| Precision | Internal | Size (bytes)
| --- | --- | ---
| 1-4 | INT16 | 2
| 5-9 | INT32 | 4
| 10-18 | INT64 | 8
| 19-38 | INT128 | 16

You can explicitly cast a number (either integer or float) to a `DECIMAL` as follows:

```cypher
RETURN CAST(127.3, "DECIMAL(5, 2)") AS result;
```
Output:
```
----------
| result |
----------
| 127.30 |
----------
```

Note that if you attempt to cast with a precision or scale that is too small, an overflow exception
will be raised:
```cypher
RETURN CAST(127.3, "DECIMAL(4, 2)");
```
```
Error: Overflow exception: To Decimal Cast Failed: 127.300000 is not in DECIMAL(4, 2) range
```

## BOOLEAN

| Size | Description
| --- | ---
| 1 byte | true/false

## STRUCT

A `STRUCT` is a mapping of key-value pairs where the keys are of the type `STRING`. `STRUCT` is a
**fixed-size** data type so values with the same `STRUCT` type must contain the same set of key-value pairs.
You can think of a `STRUCT` column as a nested single column over multiple other columns.

| Data Type | DDL definition |
| --- | --- |
| STRUCT | STRUCT(a INT64, b INT64) |

To construct a `STRUCT`, provide a mapping of keys to values as follows:

```cypher
RETURN {first: 'Adam', last: 'Smith'};
```
Output:
```
-------------------------------
| STRUCT_PACK(Adam,Smith)    |
-------------------------------
| {FIRST: Adam, LAST: Smith} |
-------------------------------
```

Functions that work on `STRUCT`s can be found [here](/cypher/expressions/struct-functions).

## MAP


A `MAP` is a dictionary of key-value pairs where all keys have the same type and all values have the
same type. `MAP` is similar to `STRUCT` in that it is an ordered list of mappings. However, `MAP` does
not need to have the same keys present for each row, and is thus more suitable when the schema of an entity
is unknown beforehand or when the schema varies per row.

`MAP`s must have a single type for all keys, and a single type for all values. Additionally, keys of
a `MAP` do not need to be `STRING`s like they do in a `STRUCT`.

| Data Type | DDL definition |
| --- | --- |
| MAP | MAP(STRING, INT64) |

To construct a `MAP`, provide a list of keys and a list of values. The keys and values must be of the same length.

Example:

```cypher
RETURN map([1, 2], ['a', 'b']) AS m;
```
Output:
```
--------------
| m          |
--------------
| {1=a, 2=b} |
--------------
```

Functions that work on map objects can be found [here](/cypher/expressions/map-functions).

## UUID

| Size | Description
| --- | ---
| 16 bytes | signed sixteen-byte integer

The data type `UUID` stores Universally Unique Identifiers (UUID) as defined by RFC 4122,
ISO/IEC 9834-8:2005, and related standards. Kuzu follows [PostgreSQL's implementation](https://www.postgresql.org/docs/13/datatype-uuid.html)
for the `UUID` format.

Example:

```cypher
RETURN UUID('A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11') as result;
```

Output:
```
---------------------------------------------
| result                                    |
---------------------------------------------
| a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11      |
---------------------------------------------
```

## STRING

| Size | Description
| --- | ---
| variable | variable-length character string

`STRING` data type supports UTF-8 encoding.

Example:

```cypher
RETURN 'Зарегистрируйтесь, σπαθιοῦ, Yen [jɛn], kΩ' AS str;
```

Output:

```
---------------------------------------------
| str                                       |
---------------------------------------------
| Зарегистрируйтесь, σπαθιοῦ, Yen [jɛn], kΩ |
---------------------------------------------
```

## NULL

| Size | Description
| --- | ---
| fixed | special value to represent unknown data

`NULL`s are special values to represent unknown data. Every node/relationship property or result of
any expression can be `NULL` in addition to the non-`NULL` domain of values they can take. For
example, boolean expressions can be true, false or `NULL`.

The `NULL` (in any of its case variations, such as `Null` or `null`) can be
used to specify a null literal. Some examples of comparisons using `NULL` are shown below.

Compare a value with `NULL`:
```cypher
RETURN 3 = null;
```
Output:
```
------------
| 3 = null |
------------
|          |
------------
```

Compare `NULL` with `NULL`:
```cypher
RETURN null = null;
```
Output:
```
---------------
| null = null |
---------------
|             |
---------------
```
Kùzu's CLI returns an empty cell to indicate nulls.

## DATE

| Size | Description
| --- | ---
| 4 bytes | year, month, day

`DATE` is specified in ISO-8601 format (`YYYY-MM-DD`).

Example:
```cypher
RETURN date('2022-06-06') as x;
```
Output:
```
--------------
| x          |
--------------
| 2022-06-06 |
--------------
```

## TIMESTAMP

| Size | Description
| --- | ---
| 4 bytes | combination of time and date

`TIMESTAMP` combines date and a time (hour, minute, second, millisecond) and is formatted
according to the ISO-8601 format (`YYYY-MM-DD hh:mm:ss[.zzzzzz][+-TT[:tt]]`),
which specifies the date (`YYYY-MM-DD`), time (`hh:mm:ss[.zzzzzz]`) and a time offset
`[+-TT[:tt]]`. Only the Date part is mandatory. If time is specified, then the millisecond
`[.zzzzzz]` part and the time offset are optional.

Example:
```cypher
RETURN timestamp("1970-01-01 00:00:00.004666-10") as x;
```
Output:
```
------------------------------
| x                          |
------------------------------
| 1970-01-01 10:00:00.004666 |
------------------------------
```

## INTERVAL

| Size | Description | Aliases
| --- | --- | ---
| 4 bytes | date/time difference | DURATION

`INTERVAL` consists of multiple date parts and represents the total time length of these date parts.
Kùzu follows [DuckDB's implementation](https://duckdb.org/docs/sql/data_types/interval) for the
interval format.

Example:
```cypher
RETURN interval("1 year 2 days") as x;
```
Output:
```
-----------------
| x             |
-----------------
| 1 year 2 days |
-----------------
```

## BLOB

| Size | Description | Aliases
| --- | --- | ---
| variable | arbitrary binary object | BYTEA

`BLOB`(**B**inary **L**arge **OB**ject) allows storage of an arbitrary binary object with up to
4KB in size in Kùzu. The database processes it as binary data because it has no knowledge as to what
the underlying data represents (e.g. image, video).

Below is an example of how to create a blob object with 3 bytes (188, 189, 186, 170):
```cypher
RETURN BLOB('\\xBC\\xBD\\xBA\\xAA') as result;
```
Output:
```
---------------------------------------------
| result                                    |
---------------------------------------------
| \xBC\xBD\xBA\xAA                          |
---------------------------------------------
```

## SERIAL

`SERIAL` is a logical data type used for creating an auto-incrementing sequence of numbers, typically
used as a unique column identifier, similar to `AUTO_INCREMENT` feature supported
by some other databases.

Here's how to use `SERIAL` on a primary key column of a node table when ingesting data from a CSV file
that has the following values:
```
// person.csv
Alice
Bob
Carol
```

```cypher
CREATE NODE TABLE Person(id SERIAL, name STRING, PRIMARY KEY(id));
COPY Person FROM 'person.csv';
MATCH (a:Person) RETURN a;
```
Output:
```
-------------------------------------------
| a                                       |
-------------------------------------------
| (label:Person, 3:0, {id:0, name:Alice}) |
-------------------------------------------
| (label:Person, 3:1, {id:1, name:Bob})   |
-------------------------------------------
| (label:Person, 3:2, {id:2, name:Carol}) |
-------------------------------------------
```

You can also use `SERIAL` to generate unique identifiers as properties in a relationship table.
Here's an example:

```cypher
CREATE REL TABLE Follows (FROM Person TO Person, relationship_id SERIAL);
```

## NODE

| Size | Description
| --- | ---
| fixed | represents a node in a graph

`NODE` is a logical data type. Internally, `NODE` is processed as `STRUCT` type. A `NODE` always contains
an internal ID field with key `_ID` and a label field with key `_LABEL`. The rest fields are node properties.

Here's how to return `NODE` column:
```cypher
MATCH (a:User)
RETURN a;
```
Output:
```
----------------------------------------------------
| a                                                |
----------------------------------------------------
| {_ID: 0:0, _LABEL: User, name: Adam, age: 30}    |
----------------------------------------------------
| {_ID: 0:1, _LABEL: User, name: Karissa, age: 40} |
----------------------------------------------------
| {_ID: 0:2, _LABEL: User, name: Zhang, age: 50}   |
----------------------------------------------------
| {_ID: 0:3, _LABEL: User, name: Noura, age: 25}   |
----------------------------------------------------
```

## REL

| Size | Description
| --- | ---
| fixed | represents a relationship in a graph

`REL` is a logical type. Internally, `REL` is processed as `STRUCT` type. A `REL` always contains a
src ID field with key `_SRC`, a dst ID field with key `_DST`, an internal ID field with key `_ID`
and a label field with key `_LABEL`. The rest fields are rel properties.

Here's how to return `REL` column:
```cypher
MATCH (a:User)-[e:Follows]->(b:User)
RETURN e;
```
Output:
```
---------------------------------------------------------
| e                                                     |
---------------------------------------------------------
| (0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1) |
---------------------------------------------------------
| (0:0)-{_LABEL: Follows, _ID: 2:1, since: 2020}->(0:2) |
---------------------------------------------------------
| (0:1)-{_LABEL: Follows, _ID: 2:2, since: 2021}->(0:2) |
---------------------------------------------------------
| (0:2)-{_LABEL: Follows, _ID: 2:3, since: 2022}->(0:3) |
---------------------------------------------------------
```

## LIST and ARRAY

Kùzu supports two list-like data types: (i) variable-length lists, simply called `LIST`, and
(ii) fixed-length lists, called `ARRAY`. Click on the card below to learn more about them.

<LinkCard
  title="LIST and ARRAY"
  href="/cypher/data-types/list"
  description="Example usage of LIST and ARRAY data types"
/>

## VARIANT

Variant is a data type that can store values of various data types (similar to the `sql_variant` data type of SQLServer).
Currently it can only be used to store [RDF literals](https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal) in [RDFGraphs](/rdf-graphs). 
That is, you cannot create a regular node or relationship table that holds a column of type VARIANT.
When working with RDFGraphs, the [Literals node table](/rdf-graphs/rdfgraphs-overview#rdfgraphs-mapping-of-triples-to-property-graph-tables)'s 
`val` column stores RDF literal values. RDF literals, and Kùzu's Variant data type can store values of different data types.
For example, consider the following triples in a Turtle file:

```turtle
@prefix kz: <http://kuzu.io/rdf-ex#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

kz:Waterloo a kz:City ;
	    kz:name "Waterloo" ;
	    kz:population 10000 ;
	    kz:altitude1 "329.0"^^xsd:decimal .
```
Suppose that you insert these into an RDFGraph named `UniKG`. You will get the following values in the `val` column 
of the Literals node table `UniKG_l`:
```cypher
MATCH (a:UniKG_r)-[p:UniKG_lt]->(o:UniKG_l)
RETURN a.iri, p.iri, o.val;
```
Output:
```
-------------------------------------------------------------------------------------------------
| a.iri                          | p.iri                                           | o.val      |
-------------------------------------------------------------------------------------------------
| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#altitude1                 | 329.000000 |
-------------------------------------------------------------------------------------------------
| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#population                | 10000      |
-------------------------------------------------------------------------------------------------
| http://kuzu.io/rdf-ex#Waterloo | http://kuzu.io/rdf-ex#name                      | Waterloo   |
-------------------------------------------------------------------------------------------------
```
In the output above the data types of the values in `o.val` are as follows (data types are not rendered in Kùzu cli's output)
- 329.000000 is a double
- 10000 is an integer
- "Waterloo" is a string

These different types are stored under the same column `val` of the `Literals` node table.
The following Kùzu data types can be stored in a Variant column. You can use the `cast` function to cast a value to a 
specific data type before storing it in a Variant column (as will be demonstrated in the `CREATE` statement 
examples momentarily).

| Kùzu Data Type | CAST Function Example |
|----------------|-----------------------|
| INT8           | cast(2, "INT8")       |
| INT16          | cast(2, "INT16")      |
| INT32          | cast(2, "INT32")      | 
| INT64          | cast(2, "INT64")      |
| UINT8          | cast(2, "UINT8")      |
| UINT16         | cast(2, "UINT16")     |
| UINT32         | cast(2, "UINT32")     | 
| UINT64         | cast(2, "UINT64")     |
| DOUBLE         | cast(4.4, "DOUBLE")   |
| FLOAT          | cast(4.4, "FLOAT")    |
| BLOB           | cast("\\xB2", "BLOB") |
| BOOL           | cast("true", "BOOL")  |
| STRING         | cast(123, "STRING")   |
| DATE           | cast("2024-01-01", "DATE") |
| TIMESTAMP      | cast("2024-01-01 11:25:30Z+00:00", "TIMESTAMP") |
| INTERVAL       | cast("1 year", "INTERVAL") |

For example, the below code adds new triples into an RDFGraph with type date and float, respectively:
```cypher
CREATE (a:UniKG_r {iri:"http://kuzu.io/rdf-ex#foo"})-[p:UniKG_lt {iri:"http://kuzu.io/rdf-ex#datepredicate"}]->(o:UniKG_l {val:cast("2024-01-01", "DATE")});
CREATE (a:UniKG_r {iri:"http://kuzu.io/rdf-ex#foo"})-[p:UniKG_lt {iri:"http://kuzu.io/rdf-ex#doublepredicate"}]->(o:UniKG_l {val:4.4});
```
Above, DATE type needs to be cast explicitly as in "cast("2024-01-01", "DATE")" while 4.4, which is of type DOUBLE, 
can be provided as is. This is because DATE is not an automatically inferred data type. The above two CREATE statements will create 
the following two triples:
```
----------------------------------------------------------------------------------
| http://kuzu.io/rdf-ex#foo | http://kuzu.io/rdf-ex#doublepredicate | 4.400000   |
----------------------------------------------------------------------------------
| http://kuzu.io/rdf-ex#foo | http://kuzu.io/rdf-ex#datepredicate   | 2024-01-01 |
----------------------------------------------------------------------------------
```

## PATH

`PATH` is a logical type. Internally, `PATH` is processed as `STRUCT` type, more specifically, a
`STRUCT{LIST[NODE], LIST[REL]}`. A `PATH` always contains a nodes field with the key `_NODES` and a
relationships field with the key `_RELS`.

#### Return `PATH` column
```cypher
MATCH p = (a:User)-[:Follows]->(b:User) 
WHERE a.name = 'Adam' AND b.name = 'Karissa' 
RETURN p;
```
Output:
```
{_NODES: [{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: User, name: Karissa, age: 40}], _RELS: [(0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1)]}
```

#### Access all nodes on a path
```cypher
MATCH p = (a:User)-[:Follows]->(b:User) 
WHERE a.name = 'Adam' AND b.name = 'Karissa' 
RETURN nodes(p);
```
Output:
```
[{_ID: 0:0, _LABEL: User, name: Adam, age: 30},{_ID: 0:1, _LABEL: User, name: Karissa, age: 40}]
```

#### Access all rels on a path
```cypher
MATCH p = (a:User)-[:Follows]->(b:User) 
WHERE a.name = 'Adam' AND b.name = 'Karissa' 
RETURN rels(p);
```
Output:
```
[(0:0)-{_LABEL: Follows, _ID: 2:0, since: 2020}->(0:1)]
```
