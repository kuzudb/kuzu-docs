---
title: Strongly Connected Components
---

A strongly connected component (SCC) in a directed graph is a maximal subgraph where every pair of vertices is mutually reachable - meaning for any two nodes u and v in the component, there exists a directed path from u to v and a directed path from v to u. 
This mutual reachability property means that nodes within an SCC form a cycle where they can all reach each other through directed paths, and no additional nodes can be added to the component while maintaining this property. 
Kuzu implements two types of scc algorithm
- Parallel BFS based [coloring algorithm](https://www.cs.rpi.edu/~slotag/pub/SCC-IPDPS14.pdf)
- DFS based [kosaraju algorithm](https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm)

## Syntax

```
CALL strongly_connected_components(
    graph_name
)
RETURN node, group_id
```

```
CALL strongly_connected_components_kosaraju(
    graph_name
)
RETURN node, group_id
```

**Parameters**

| Parameter | Type | Optional | Default | Description |
|-----------|------|----------|---------|-------------|
| graph_name | STRING | No | - | Name of the projected graph to run the algorithm on |

**Return** 

| Column | Type | Description |
|--------|------|-------------|
| node | NODE | Node object |
| group_id | INT64 | The group ID that the node belongs to |

## Example 

Define schema
```cypher
CREATE NODE TABLE Node(id STRING PRIMARY KEY);
CREATE REL TABLE Edge(FROM Node to Node);
```
Insert nodes and edges
```cypher
CREATE (u0:Node {id: 'A'}),
        (u1:Node {id: 'B'}),
        (u2:Node {id: 'C'}),
        (u3:Node {id: 'D'}),
        (u4:Node {id: 'E'}),
        (u5:Node {id: 'F'}),
        (u6:Node {id: 'G'}),
        (u7:Node {id: 'H'}),
        (u8:Node {id: 'I'}),
        (u0)-[:Edge]->(u1),
        (u1)-[:Edge]->(u2),
        (u1)-[:Edge]->(u4),
        (u2)-[:Edge]->(u2),
        (u2)-[:Edge]->(u5),
        (u3)-[:Edge]->(u1),
        (u3)-[:Edge]->(u6),
        (u4)-[:Edge]->(u0),
        (u4)-[:Edge]->(u5),
        (u4)-[:Edge]->(u3),
        (u5)-[:Edge]->(u7),
        (u6)-[:Edge]->(u4),
        (u6)-[:Edge]->(u5),
        (u7)-[:Edge]->(u8),
        (u8)-[:Edge]->(u5);
```
Project graph
```cypher
CALL create_projected_graph('Graph', ['Node'], ['Edge']);
```
Run wcc
```cypher
CALL strongly_connected_components('Graph') RETURN group_id, collect(node.id);
CALL strongly_connected_components_kosaraju('Graph') RETURN group_id, collect(node.id);
┌──────────┬──────────────────┐
│ group_id │ COLLECT(node.id) │
│ INT64    │ STRING[]         │
├──────────┼──────────────────┤
│ 3        │ [G,E,D,A,B]      │
│ 0        │ [I,F,H]          │
│ 8        │ [C]              │
└──────────┴──────────────────┘
```

## Frquently asked questions

**How is `group_id` assigned?**

`group_id` is assigned based on internal node offsets. Currently there is no way to assign `group_id` based on node properties.

**What's the difference between `scc` and `scc_kosaraju`?**

`scc` is a parallel BFS based algorithm. While `scc_kosaraju` is a DFS based algorithm.
Due to the nature of DFS, `scc_kosaraju` can only run in single-thread mode. It is recommended to use 
`scc` in most cases except 
- your graph is very sparse, i.e. with a large number of nodes but very small number of edges; or
- your graph has a very high diameter