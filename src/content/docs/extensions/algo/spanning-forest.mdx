---
title: Spanning Forest
---

The Spanning Forest algorithm finds a minimal set of edges that connect all nodes within each
connected component of a graph without forming cycles. Spanning forests are commonly used in
tasks such as extracting the main connectivity structure of large graphs, clustering nodes based on connectivity,
and building tree-based indexes for efficient graph traversal.

A spanning forest differs from a minimum spanning tree (MST) in that it can handle disconnected graphs.
While an MST connects all nodes in a single connected graph with minimum total edge weight, a spanning
forest produces multiple trees, each representing a connected component. This makes spanning forests particularly
useful for analyzing graphs with isolated clusters or when you need to preserve the natural partitioning
of your data while still finding optimal connections within each component.

Kuzu implements a serial version of Kruskal's algorithm based on [Graaf](https://bobluppes.github.io/graaf/).
In Kuzu, both base and projected graphs are directed. The Spanning Forest implementation in Kuzu operates on
an undirected version of the projected graph, i.e., each edge is treated as undirected.

## Syntax

```cypher
CALL spanning_forest(
    <GRAPH_NAME>,
    weight_property:=<WEIGHT_PROPERTY>,
    variant:='min' OR 'max'
)
RETURN src, dst, rel, forest_id;
```

**Alias**: `sf`

Required arguments:

- `GRAPH_NAME`: Name of the projected graph to run the algorithm on
    - Type: `STRING`

Optional arguments:

- `weight_property`: Some numerical property on the rel table to be used as a weight.
    - Type: `STRING`
    - Default: If omitted, the algorithm will run assuming all edges have weight 1.
- `variant`: Sets the objective of the algorithm to retrieve either a minimum, `min` or maximum, `max` spanning forest.
    - Type: `STRING`
    - Valid values: `min`, `max`
    - Default: `min`

Returns:

Each row in the output table represents an edge that belongs to the spanning forest.
Isolated vertices are not included.

- `src`: A node object representing the source node of `rel`.
- `dst`: A node object representing the destination node of `rel`.
- `rel`: A rel object representing an edge in the forest.
- `forest_id`: An ID of the individual tree that `rel` belongs to.

:::note[Note]
This algorithm currently only works on projected graphs with one node table and one rel table.
:::

## Example

Create the node and relationship tables:
```cypher
CREATE NODE TABLE Person(id INT64 PRIMARY KEY, name STRING);
CREATE REL TABLE KNOWS(FROM Person TO Person, weight INT64);
```
Insert nodes and edges:
```cypher
CREATE (u0:Person {id: 0, name: 'Alice'}),
        (u1:Person {id: 1, name: 'Bob'}),
        (u2:Person {id: 2, name: 'Charlie'}),
        (u3:Person {id: 3, name: 'Derek'}),
        (u4:Person {id: 4, name: 'Eve'}),
        (u5:Person {id: 5, name: 'Frank'}),
        (u6:Person {id: 6, name: 'George'}),
        (u7:Person {id: 7, name: 'Hina'}),
        (u8:Person {id: 8, name: 'Ivy'}),
        (u9:Person {id: 9, name: 'Jack'}),
        (u0)-[:KNOWS {weight: 5}]->(u1),
        (u0)-[:KNOWS {weight: 6}]->(u2),
        (u1)-[:KNOWS {weight: 8}]->(u2),
        (u2)-[:KNOWS {weight: 3}]->(u3),
        (u3)-[:KNOWS {weight: 3}]->(u4),
        (u5)-[:KNOWS {weight: 10}]->(u6),
        (u5)-[:KNOWS {weight: 10}]->(u7),
        (u6)-[:KNOWS {weight: 3}]->(u7),
        (u7)-[:KNOWS {weight: 10}]->(u8),
        (u8)-[:KNOWS {weight: 3}]->(u9);
```
Create a projected graph from the node and relationship tables:
```cypher
CALL PROJECT_GRAPH('ProjectedGraph', ['Person'], ['KNOWS']);
```

:::note[Tip]
The algorithm can be run in three modes, depending on whether you specify a `weight_property` and `variant`:

**Minimum spanning forest** (`variant:='min'`)
Finds the forest with the smallest possible total edge weight.
Use this when you want the most cost-efficient connections, such as for network design or infrastructure planning.

**Maximum spanning forest** (`variant:='max'`)
Finds the forest with the largest possible total edge weight.
Use this to highlight the strongest, most important, or most reliable connections in your network.

**Unweighted** (no `weight_property` provided)
All edges are treated equally, and the algorithm returns an arbitrary spanning forest.
Use this when weights are irrelevant or unavailable.
:::

Run the unweighted variant of the spanning forest algorithm on the projected graph:
```cypher
CALL spanning_forest('ProjectedGraph')
    RETURN src.name AS src, dst.name AS dst, rel.weight AS weight, forest_id
    ORDER BY forest_id, src.name;
```
```table
┌─────────┬─────────┬────────┬───────────┐
│ src     │ dst     │ weight │ FOREST_ID │
│ STRING  │ STRING  │ INT64  │ UINT64    │
├─────────┼─────────┼────────┼───────────┤
│ Alice   │ Charlie │ 6      │ 0         │
│ Bob     │ Charlie │ 8      │ 0         │
│ Charlie │ Derek   │ 3      │ 0         │
│ Derek   │ Eve     │ 3      │ 0         │
│ Frank   │ Hina    │ 10     │ 5         │
│ George  │ Hina    │ 3      │ 5         │
│ Hina    │ Ivy     │ 10     │ 5         │
│ Ivy     │ Jack    │ 3      │ 5         │
└─────────┴─────────┴────────┴───────────┘
```

Run the min variant of the spanning forest algorithm on the projected graph:
```cypher
CALL spanning_forest('ProjectedGraph', variant:='min', weight_property:='weight')
RETURN src.name AS src, dst.name AS dst, rel.weight AS weight, forest_id
ORDER BY forest_id, src.name;
```
```table
┌─────────┬─────────┬────────┬───────────┐
│ src     │ dst     │ weight │ FOREST_ID │
│ STRING  │ STRING  │ INT64  │ UINT64    │
├─────────┼─────────┼────────┼───────────┤
│ Alice   │ Bob     │ 5      │ 0         │
│ Alice   │ Charlie │ 6      │ 0         │
│ Charlie │ Derek   │ 3      │ 0         │
│ Derek   │ Eve     │ 3      │ 0         │
│ Frank   │ Hina    │ 10     │ 5         │
│ George  │ Hina    │ 3      │ 5         │
│ Hina    │ Ivy     │ 10     │ 5         │
│ Ivy     │ Jack    │ 3      │ 5         │
└─────────┴─────────┴────────┴───────────┘
```

Run the max variant of the spanning forest algorithm on the projected graph:
```cypher
CALL spanning_forest('ProjectedGraph', variant:='max', weight_property:='weight')
    RETURN src.name AS src, dst.name AS dst, rel.weight AS weight, forest_id
    ORDER BY forest_id, src.name;
```
```table
┌─────────┬─────────┬────────┬───────────┐
│ src     │ dst     │ weight │ FOREST_ID │
│ STRING  │ STRING  │ INT64  │ UINT64    │
├─────────┼─────────┼────────┼───────────┤
│ Alice   │ Charlie │ 6      │ 2         │
│ Bob     │ Charlie │ 8      │ 2         │
│ Charlie │ Derek   │ 3      │ 2         │
│ Derek   │ Eve     │ 3      │ 2         │
│ Frank   │ George  │ 10     │ 8         │
│ Frank   │ Hina    │ 10     │ 8         │
│ Hina    │ Ivy     │ 10     │ 8         │
│ Ivy     │ Jack    │ 3      │ 8         │
└─────────┴─────────┴────────┴───────────┘
```
