---
title: Spanning Forest
---

The Spanning Forest algorithm (also known as Minimum Spanning Forest when run in its cost-minimizing form)
finds a minimal set of edges that connect all nodes within each connected component of a graph without forming
cycles. This algorithm treats all edges as undirected during processing. The result is a table of edges that
belong to the spanning forest, so isolated vertices are not included. Spanning forests are commonly used in
tasks such as extracting the main connectivity structure of large graphs, clustering nodes based on connectivity,
and building tree-based indexes for efficient graph traversal.

Kuzu implements a serial version of Kruskal's algorithm based on [Graaf lib](https://bobluppes.github.io/graaf/).

## Syntax

```cypher
CALL spanning_forest(
    <GRAPH_NAME>,
    weight_property:='age',
    variant:='min
)
RETURN src, dst, rel, forest_id;
```

**Alias**: `sf`

Required arguments:

- `GRAPH_NAME`: Name of the projected graph to run the algorithm on
    - Type: `STRING`

:::note[Note]
This algorithm currently only works on one node table and one rel table.
:::

Optional arguments:

- `weight_property`: Some numerical on the rel table to be used as a weight.
    - Type: `STRING`
    - Default: If omitted, the algorithm will run treating all edges with weight 1.
- `variant`: Sets the objective of the algorithm to retrieve either a minimum, `min` or maximum, `max` spanning forest.
    - Type: `STRING`
    - Default: 'min'

Returns:

- `src`: A node object representing the source node of the `rel`.
- `dst`: A node object representing the destination node of the `rel`.
- `rel`: A rel object representing an edge in the forest.
- `forest_id`: An id indicating the tree (component) the `rel` belong to.

## Example

Create the node and relationship tables:
```cypher
CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
```
Insert nodes and edges:
```cypher
CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u4)-[:Edge {weight: 2}]->(u9);
```
Create a projected graph from the node and relationship tables:
```cypher
CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
```

:::note[Tip]
The algorithm can be run in three modes, depending on whether you specify a `weight_property` and `variant`:

**Unweighted** (no `weight_property` provided)
All edges are treated equally, and the algorithm returns an arbitrary spanning forest.
Use this when weights are irrelevant or unavailable.

**Minimum spanning forest** (`variant:='min'`)
Finds the forest with the smallest possible total edge weight.
Use this when you want the most cost-efficient connections, such as for network design or infrastructure planning.

**Maximum spanning forest** (`variant:='max'`)
Finds the forest with the largest possible total edge weight.
Use this to highlight the strongest, most important, or most reliable connections in your network.
:::

Run the spanning forest algorithm on the projected graph:
```cypher
CALL spanning_forest('Graph')
    RETURN src.id AS src, dst.id AS dst, rel.weight as weight, forest_id
    ORDER BY src.id;
```
```table
┌───────┬───────┬────────┬───────────┐
│ src   │ dst   │ weight │ FOREST_ID │
│ INT64 │ INT64 │ INT64  │ UINT64    │
├───────┼───────┼────────┼───────────┤
│ 0     │ 2     │ 6      │ 0         │
│ 1     │ 2     │ 8      │ 0         │
│ 2     │ 5     │ 15     │ 0         │
│ 2     │ 3     │ 3      │ 0         │
│ 3     │ 4     │ 3      │ 0         │
│ 4     │ 9     │ 2      │ 0         │
│ 5     │ 7     │ 10     │ 0         │
│ 5     │ 6     │ 10     │ 0         │
│ 8     │ 9     │ 3      │ 0         │
└───────┴───────┴────────┴───────────┘
```

Run the spanning forest algorithm (min variant) on the projected graph:
```cypher
CALL spanning_forest('Graph', variant:='min', weight_property:='weight')
    RETURN src.id AS src, dst.id AS dst, rel.weight as weight, forest_id
    ORDER BY src.id;
```
```table
┌───────┬───────┬────────┬───────────┐
│ src   │ dst   │ weight │ FOREST_ID │
│ INT64 │ INT64 │ INT64  │ UINT64    │
├───────┼───────┼────────┼───────────┤
│ 0     │ 1     │ 5      │ 0         │
│ 0     │ 2     │ 6      │ 0         │
│ 2     │ 3     │ 3      │ 0         │
│ 3     │ 4     │ 3      │ 0         │
│ 4     │ 9     │ 2      │ 0         │
│ 5     │ 7     │ 10     │ 0         │
│ 6     │ 7     │ 3      │ 0         │
│ 7     │ 8     │ 10     │ 0         │
│ 8     │ 9     │ 3      │ 0         │
└───────┴───────┴────────┴───────────┘
```

Run the spanning forest algorithm (max variant) on the projected graph:
```cypher
CALL spanning_forest('Graph', variant:='max', weight_property:='weight')
    RETURN src.id AS src, dst.id AS dst, rel.weight as weight, forest_id
    ORDER BY src.id;
```
```table
┌───────┬───────┬────────┬───────────┐
│ src   │ dst   │ weight │ FOREST_ID │
│ INT64 │ INT64 │ INT64  │ UINT64    │
├───────┼───────┼────────┼───────────┤
│ 0     │ 2     │ 6      │ 2         │
│ 1     │ 2     │ 8      │ 2         │
│ 2     │ 5     │ 15     │ 2         │
│ 2     │ 3     │ 3      │ 2         │
│ 3     │ 4     │ 3      │ 2         │
│ 5     │ 6     │ 10     │ 2         │
│ 5     │ 7     │ 10     │ 2         │
│ 7     │ 8     │ 10     │ 2         │
│ 8     │ 9     │ 3      │ 2         │
└───────┴───────┴────────┴───────────┘
```
